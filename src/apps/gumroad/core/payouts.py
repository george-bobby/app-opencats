import calendar
import json
import uuid
from collections import defaultdict
from datetime import datetime
from typing import Any

from apps.gumroad.config.settings import settings
from apps.gumroad.utils.mysql import create_mysql_client
from common.logger import logger


# Configuration file path
PAYOUTS_CONFIG_PATH = settings.DATA_PATH / "generated" / "payouts_config.json"


async def generate_payouts(last_n_months: int = 24):
    """
    Generate payouts configuration and save to JSON file.

    Args:
        last_n_months: Number of months to look back from current date
    """
    config = {"last_n_months": last_n_months, "generated_at": datetime.now().isoformat()}

    # Create generated directory if it doesn't exist
    PAYOUTS_CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)

    # Save configuration to JSON file
    with PAYOUTS_CONFIG_PATH.open("w") as f:
        json.dump(config, f, indent=2)

    logger.info(f"Generated payouts configuration: {config}")
    logger.info(f"Configuration saved to: {PAYOUTS_CONFIG_PATH}")

    return config


async def seed_payouts():
    """
    Get all purchases and group by month to create payout records with proper balance tracking.
    Reads last_n_months from the configuration file generated by generate_payouts.
    """
    # Read configuration from JSON file
    if not PAYOUTS_CONFIG_PATH.exists():
        raise FileNotFoundError(f"Payouts configuration file not found at {PAYOUTS_CONFIG_PATH}. Please run generate_payouts first.")

    with PAYOUTS_CONFIG_PATH.open("r") as f:
        config = json.load(f)

    last_n_months = config["last_n_months"]
    logger.start(f"Seeding payouts for the last {last_n_months} months")

    client = None
    try:
        # Create MySQL client connection
        client = await create_mysql_client()
        query = "DELETE from payments"
        await client.execute(query)

        # Get all purchases with balance information
        query = """
        SELECT 
            p.id as purchase_id,
            p.seller_id,
            p.price_cents,
            p.fee_cents,
            p.created_at,
            p.purchase_success_balance_id,
            p.purchase_refund_balance_id,
            p.purchase_chargeback_balance_id
        FROM purchases p
        WHERE p.seller_id = 1
        ORDER BY p.created_at DESC
        """

        # Get all purchases
        purchases = await client.fetch_dict_all(query)

        logger.info(f"Found {len(purchases)} total purchases")

        # Group purchases by month and seller in Python
        # Use explicit type structure to avoid linting issues
        monthly_seller_data: dict[str, dict[int, dict[str, Any]]] = defaultdict(lambda: defaultdict(dict))

        for purchase in purchases:
            # Extract month string from created_at
            month = purchase["created_at"].strftime("%Y-%m")
            seller_id = purchase["seller_id"]

            # Initialize seller data for this month if not exists
            if seller_id not in monthly_seller_data[month]:
                monthly_seller_data[month][seller_id] = {
                    "total_amount_cents": 0,
                    "total_commission_cents": 0,
                    "purchase_count": 0,
                    "purchases": [],
                }

            # Calculate seller commission (what the seller actually receives)
            # This matches Ruby Purchase#payment_cents and Purchase::Accounting#net_total methods
            # Formula: price_cents - fee_cents
            #
            # Where:
            # - price_cents: Product price + shipping + taxes (if excluded from price)
            # - fee_cents: All Gumroad fees (10% flat + 50¢ fixed + 2.9% + 30¢ processor fees)
            # - commission_cents: Net amount paid to seller (seller's revenue)
            commission_cents = purchase["price_cents"] - purchase["fee_cents"]

            # Add to monthly totals
            monthly_seller_data[month][seller_id]["total_amount_cents"] += purchase["price_cents"]
            monthly_seller_data[month][seller_id]["total_commission_cents"] += commission_cents
            monthly_seller_data[month][seller_id]["purchase_count"] += 1
            monthly_seller_data[month][seller_id]["purchases"].append(purchase)

        logger.info(f"Grouped into {len(monthly_seller_data)} months")

        # Create payout records and balance records
        payout_records = []
        balance_records = []

        for month, sellers_data in monthly_seller_data.items():
            for seller_id, data in sellers_data.items():
                amount_cents = data["total_commission_cents"]

                # Skip if no commission to pay out
                if amount_cents <= 0:
                    continue

                # Calculate processor fee (2.9% + $0.30, minimum $1.00)
                fee_percentage = int(amount_cents * 0.029)
                fee_fixed = 30
                fee_total = fee_percentage + fee_fixed
                processor_fee_cents = max(100, fee_total)

                # Calculate period end date
                year, month_num = month.split("-")
                year, month_num = int(year), int(month_num)
                last_day = calendar.monthrange(year, month_num)[1]
                period_end_date = datetime(year, month_num, last_day)
                payout_date = period_end_date.strftime("%Y-%m-%d 17:00:00")

                # If the period end date is in the past, mark as completed
                state = "completed" if period_end_date < datetime.now() else "pending"

                # Generate correlation_id for this payout
                correlation_id = str(uuid.uuid4())

                payout_record = {
                    "user_id": seller_id,
                    "state": state,
                    "created_at": payout_date,
                    "updated_at": payout_date,
                    "txn_id": None,
                    "processor_fee_cents": int(processor_fee_cents),
                    "correlation_id": correlation_id,
                    "processor": "paypal",
                    "amount_cents": amount_cents,
                    "payment_address": None,
                    "payout_period_end_date": period_end_date.strftime("%Y-%m-%d"),
                    "bank_account_id": None,
                    "amount_cents_in_local_currency": None,
                    "stripe_connect_account_id": None,
                    "stripe_transfer_id": None,
                    "stripe_internal_transfer_id": None,
                    "currency": "usd",
                    "flags": 0,
                    "json_data": "{}",
                    "failure_reason": None,
                    "processor_reversing_payout_id": None,
                }

                payout_records.append(payout_record)

                # Create balance record for this payout period
                balance_record = {
                    "user_id": seller_id,
                    "amount_cents": amount_cents,
                    "date": period_end_date.strftime("%Y-%m-%d"),
                    "created_at": payout_date,
                    "updated_at": payout_date,
                    "holding_amount_cents": amount_cents,
                    "currency": "usd",
                    "holding_currency": "usd",
                    "state": "available",
                    "merchant_account_id": 1,
                }

                balance_records.append(balance_record)

        # Insert balance records first (they're referenced by payments)
        if balance_records:
            logger.info("Inserting balance records...")
            await client.insert_many("balances", balance_records)
            logger.info(f"Successfully inserted {len(balance_records)} balance records")

            # Get the inserted balance IDs for linking to payments
            balance_query = """
            SELECT id, user_id, date, merchant_account_id
            FROM balances 
            WHERE user_id = 1 AND merchant_account_id = 1
            ORDER BY date DESC
            LIMIT %s
            """

            inserted_balances = await client.fetch_dict_all(balance_query, (len(balance_records),))
            balance_lookup = {
                (
                    balance["user_id"],
                    balance["date"].strftime("%Y-%m-%d"),  # Convert date to string
                    balance["merchant_account_id"],
                ): balance["id"]
                for balance in inserted_balances
            }

            # Update payout records to reference the balance IDs
            for payout_record in payout_records:
                balance_date = payout_record["payout_period_end_date"]
                user_id = payout_record["user_id"]
                balance_key = (user_id, balance_date, 1)

                if balance_key in balance_lookup:
                    # Link purchases in this period to the balance
                    month_key = balance_date[:7]  # YYYY-MM format
                    purchases_in_period = monthly_seller_data[month_key][user_id]["purchases"]

                    # Update purchases to link them to this balance
                    balance_id = balance_lookup[balance_key]
                    for purchase in purchases_in_period:
                        if not purchase["purchase_success_balance_id"]:
                            await client.execute(
                                "UPDATE purchases SET purchase_success_balance_id = %s WHERE id = %s",
                                (balance_id, purchase["purchase_id"]),
                            )

        # Insert payout records
        if payout_records:
            # Log first record for debugging
            if payout_records:
                first_record = payout_records[0]
                logger.info(
                    f"Sample record to insert: user_id={first_record['user_id']}, amount_cents={first_record['amount_cents']}, processor_fee_cents={first_record['processor_fee_cents']}"
                )

            inserted_count = await client.insert_many("payments", payout_records)
            logger.info(f"Successfully inserted {inserted_count} payout records")

            # Get the inserted payment IDs
            payment_query = """
            SELECT id, user_id, payout_period_end_date, correlation_id
            FROM payments 
            WHERE user_id = 1 
            ORDER BY created_at DESC
            LIMIT %s
            """

            inserted_payments = await client.fetch_dict_all(payment_query, (len(payout_records),))
            payment_lookup = {(payment["user_id"], payment["payout_period_end_date"]): payment["id"] for payment in inserted_payments}

            # Create payments_balances relationships
            payments_balances_records = []
            for payout_record in payout_records:
                balance_date = payout_record["payout_period_end_date"]
                user_id = payout_record["user_id"]
                balance_key = (user_id, balance_date, 1)
                payment_key = (user_id, balance_date)

                if balance_key in balance_lookup and payment_key in payment_lookup:
                    payments_balances_records.append(
                        {
                            "payment_id": payment_lookup[payment_key],
                            "balance_id": balance_lookup[balance_key],
                        }
                    )

            if payments_balances_records:
                await client.insert_many("payments_balances", payments_balances_records)
                logger.info(f"Successfully created {len(payments_balances_records)} payment-balance relationships")

        else:
            logger.info("No payout records to insert")

        completed_payouts = [record for record in payout_records if record["state"] == "completed"]
        completed_months = [record["payout_period_end_date"][:7] for record in completed_payouts]

        total_sales_cents = 0
        total_fee_cents = 0

        for month in completed_months:
            if month in monthly_seller_data:
                for _seller_id, data in monthly_seller_data[month].items():
                    for purchase in data["purchases"]:
                        total_sales_cents += purchase["price_cents"]
                        total_fee_cents += purchase["fee_cents"]

        logger.succeed("Payouts seeded successfully")

    except Exception as e:
        logger.error(f"Error creating payouts: {e}")
        raise
    finally:
        if client:
            await client.disconnect()
